/**
 * Persona Lab Store
 *
 * Simplified store for the graph-based persona conversation system.
 * Uses TanStack Query for server state, Zustand only for:
 * - UI state (viewMode)
 * - Persisted chat messages (graphMessages)
 * - Real-time graph data from mutations (apiGraphNodes/Edges)
 * - STAR gaps tracking
 */
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import type {
	CoverageMetrics,
	GraphMessageResponse,
	PersonaEdgeDto,
	PersonaNodeDto,
	PersonaStateResponse,
} from "@/lib/generated/api/models";

// Frontend-specific types not generated by Orval
export interface ConversationMessage {
	id: string;
	role: "assistant" | "user";
	content: string;
	type: "text" | "question" | "completion";
	timestamp: string;
}

// STAR framework keys for gap tracking
export type StarStructureKey =
	| "situation"
	| "task"
	| "action"
	| "result"
	| "emotion"
	| "insight";

// View mode for canvas/list toggle
export type ViewMode = "list" | "canvas";

// Mock mode scenario types (development only)
export type ConversationScenario =
	| "fresh-start"
	| "building-momentum"
	| "tension-discovery"
	| "completion-ready";

// Store State
interface PersonaStoreState {
	// === UI State ===
	viewMode: ViewMode;

	// === Mock Mode (Development Only) ===
	mockMode: boolean;
	mockScenario: ConversationScenario;

	// === Graph-Based Conversation State (from chat mutations) ===
	apiGraphNodes: PersonaNodeDto[];
	apiGraphEdges: PersonaEdgeDto[];
	coverage: CoverageMetrics;
	completionReady: boolean;
	totalNodeCount: number;
	starGapsMap: Record<string, StarStructureKey[]>; // nodeId -> missing STAR elements

	// === Persisted Chat Messages ===
	graphMessages: ConversationMessage[];

	// === Actions ===

	// UI actions
	setViewMode: (mode: ViewMode) => void;

	// Mock mode actions (development only)
	setMockMode: (enabled: boolean) => void;
	setMockScenario: (scenario: ConversationScenario) => void;

	// Graph update actions (called from ChatSidebar mutation callbacks)
	processGraphUpdate: (response: GraphMessageResponse) => void;
	setCoverage: (coverage: CoverageMetrics) => void;
	setCompletionReady: (ready: boolean) => void;
	addStarGaps: (nodeId: string, gaps: StarStructureKey[]) => void;
	clearApiGraph: () => void;
	getStarGapsForNode: (nodeId: string) => StarStructureKey[];

	// Chat message actions
	addGraphMessage: (message: ConversationMessage) => void;
	clearGraphMessages: () => void;

	// Utility
	resetPersona: () => void;
	syncWithServer: (data: PersonaStateResponse) => void;
	syncGraph: (nodes: PersonaNodeDto[], edges: PersonaEdgeDto[]) => void;

	// Hydration state
	_hasHydrated: boolean;
	setHasHydrated: (state: boolean) => void;
}

// Initial state
const initialState = {
	// UI state
	viewMode: "canvas" as ViewMode,

	// Mock mode (development only)
	mockMode: false,
	mockScenario: "fresh-start" as ConversationScenario,

	// Graph-based conversation state
	apiGraphNodes: [] as PersonaNodeDto[],
	apiGraphEdges: [] as PersonaEdgeDto[],
	coverage: {
		goals: 0,
		evidence: 0,
		skills: 0,
		values: 0,
		tensions: 0,
		lowestCategory: undefined,
		overallProgress: 0,
	} as CoverageMetrics,
	completionReady: false,
	totalNodeCount: 0,
	starGapsMap: {} as Record<string, StarStructureKey[]>,

	// Persisted chat messages
	graphMessages: [] as ConversationMessage[],

	// Hydration state
	_hasHydrated: false,
};

export const usePersonaStore = create<PersonaStoreState>()(
	persist(
		(set, get) => ({
			// Initial State
			...initialState,

			// === UI Actions ===
			setViewMode: (mode) => set({ viewMode: mode }),

			// === Mock Mode Actions ===
			setMockMode: (enabled) => set({ mockMode: enabled }),
			setMockScenario: (scenario) => set({ mockScenario: scenario }),

			// === Graph Update Actions ===

			// Process graph update from API response (called from ChatSidebar mutation callbacks)
			processGraphUpdate: (response: GraphMessageResponse) => {
				set((state) => {
					// Add new nodes (avoid duplicates) - handle optional nodesCreated
					const nodesCreated = response.nodesCreated ?? [];
					const existingNodeIds = new Set(state.apiGraphNodes.map((n) => n.id));
					const newNodes = nodesCreated.filter(
						(n) => n.id && !existingNodeIds.has(n.id),
					);

					// Add new edges (avoid duplicates) - handle optional edgesCreated
					const edgesCreated = response.edgesCreated ?? [];
					const existingEdgeIds = new Set(state.apiGraphEdges.map((e) => e.id));
					const newEdges = edgesCreated.filter(
						(e) => e.id && !existingEdgeIds.has(e.id),
					);

					// Update STAR gaps for the last story if provided
					const starGapsMap = { ...state.starGapsMap };
					if (
						response.starGapsForLastStory &&
						response.starGapsForLastStory.length > 0
					) {
						// Find the last key_story node created
						const lastStoryNode = [...newNodes]
							.reverse()
							.find((n) => n.type === "key_story");
						if (lastStoryNode?.id) {
							// Cast string[] to StarStructureKey[] since API returns string[]
							starGapsMap[lastStoryNode.id] =
								response.starGapsForLastStory as StarStructureKey[];
						}
					}

					return {
						apiGraphNodes: [...state.apiGraphNodes, ...newNodes],
						apiGraphEdges: [...state.apiGraphEdges, ...newEdges],
						coverage: response.coverage ?? state.coverage,
						completionReady: response.completionReady ?? state.completionReady,
						totalNodeCount: response.totalNodeCount ?? state.totalNodeCount,
						starGapsMap,
					};
				});
			},

			// Set coverage metrics
			setCoverage: (coverage: CoverageMetrics) => set({ coverage }),

			// Set completion ready flag
			setCompletionReady: (ready: boolean) => set({ completionReady: ready }),

			// Add STAR gaps for a specific node
			addStarGaps: (nodeId: string, gaps: StarStructureKey[]) => {
				set((state) => ({
					starGapsMap: {
						...state.starGapsMap,
						[nodeId]: gaps,
					},
				}));
			},

			// Clear API graph data (used on reset)
			clearApiGraph: () =>
				set({
					apiGraphNodes: [],
					apiGraphEdges: [],
					coverage: {
						goals: 0,
						evidence: 0,
						skills: 0,
						values: 0,
						tensions: 0,
						lowestCategory: undefined,
						overallProgress: 0,
					},
					completionReady: false,
					totalNodeCount: 0,
					starGapsMap: {},
				}),

			// Get STAR gaps for a specific node
			getStarGapsForNode: (nodeId: string): StarStructureKey[] => {
				return get().starGapsMap[nodeId] || [];
			},

			// === Chat Message Actions ===

			// Add a message to the graph conversation
			addGraphMessage: (message: ConversationMessage) => {
				set((state) => ({
					graphMessages: [...state.graphMessages, message],
				}));
			},

			// Clear all graph messages (used on reset)
			clearGraphMessages: () => set({ graphMessages: [] }),

			// === Utility ===

			// Reset all persona data
			resetPersona: () => set(initialState),

			// Sync state from server response (GET /v1/persona)
			syncWithServer: (data: PersonaStateResponse) => {
				set((state) => {
					// Transform API messages to store format
					const serverMessages: ConversationMessage[] =
						data.conversationHistory?.map((msg) => {
							// Map API message type to store message type
							let mappedType: ConversationMessage["type"] = "text";
							if (msg.type === "track_complete") mappedType = "completion";
							// track_selection and text map to "text" for now, or could vary

							return {
								id: msg.id || `msg-${Date.now()}-${Math.random()}`,
								role: (msg.role as "user" | "assistant") || "assistant",
								content: msg.content || "",
								type: mappedType,
								timestamp: msg.timestamp || new Date().toISOString(),
							};
						}) || [];

					// Only update if server has data
					const newMessages =
						serverMessages.length > 0 ? serverMessages : state.graphMessages;

					return {
						graphMessages: newMessages,
					};
				});
			},

			// Sync graph data (GET /v1/persona-graph)
			syncGraph: (nodes: PersonaNodeDto[], edges: PersonaEdgeDto[]) => {
				set({
					apiGraphNodes: nodes,
					apiGraphEdges: edges,
				});
			},

			// Hydration state
			setHasHydrated: (state) => set({ _hasHydrated: state }),
		}),
		{
			name: "leaply-persona-store-v4", // Bump version to clear old data
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				// Only persist essential data
				viewMode: state.viewMode,
				apiGraphNodes: state.apiGraphNodes,
				apiGraphEdges: state.apiGraphEdges,
				coverage: state.coverage,
				completionReady: state.completionReady,
				totalNodeCount: state.totalNodeCount,
				starGapsMap: state.starGapsMap,
				graphMessages: state.graphMessages,
			}),
			onRehydrateStorage: () => (state, error) => {
				if (error) {
					console.error("Persona store hydration error:", error);
				}
				state?.setHasHydrated(true);
			},
		},
	),
);

// Register hydration listener using persist API
if (typeof window !== "undefined") {
	if (usePersonaStore.persist.hasHydrated()) {
		usePersonaStore.getState().setHasHydrated(true);
	}
	usePersonaStore.persist.onFinishHydration(() => {
		usePersonaStore.getState().setHasHydrated(true);
	});
}

// Selectors for common use cases
export const selectViewMode = (state: PersonaStoreState) => state.viewMode;
export const selectApiGraphNodes = (state: PersonaStoreState) =>
	state.apiGraphNodes;
export const selectApiGraphEdges = (state: PersonaStoreState) =>
	state.apiGraphEdges;
export const selectCoverage = (state: PersonaStoreState) => state.coverage;
export const selectCompletionReady = (state: PersonaStoreState) =>
	state.completionReady;
export const selectTotalNodeCount = (state: PersonaStoreState) =>
	state.totalNodeCount;
export const selectStarGapsMap = (state: PersonaStoreState) =>
	state.starGapsMap;
export const selectGraphMessages = (state: PersonaStoreState) =>
	state.graphMessages;

// Re-export generated types for convenience
export type {
	CoverageMetrics,
	GraphMessageResponse,
	PersonaEdgeDto,
	PersonaNodeDto,
} from "@/lib/generated/api/models";
