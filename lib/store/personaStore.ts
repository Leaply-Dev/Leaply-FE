/**
 * Persona Lab Store
 *
 * Simplified store for the graph-based persona conversation system.
 * Uses TanStack Query for server state, Zustand only for:
 * - UI state (viewMode)
 * - Persisted chat messages (graphMessages)
 * - Real-time graph data from mutations (apiGraphNodes/Edges)
 * - STAR gaps tracking
 */
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import type {
	CoverageMetrics,
	GraphMessageResponse,
	PersonaEdgeDto,
	PersonaNodeDto,
	PersonaStateResponse,
} from "@/lib/generated/api/models";

// Frontend-specific types not generated by Orval
export interface ConversationMessage {
	id: string;
	role: "assistant" | "user";
	content: string;
	type: "text" | "question" | "completion";
	timestamp: string;
	/** Duration in milliseconds for how long the AI took to respond */
	thinkingDuration?: number;
	/** Status of the message for optimistic UI updates */
	status?: "sending" | "sent" | "error";
}

// STAR framework keys for gap tracking
export type StarStructureKey =
	| "situation"
	| "task"
	| "action"
	| "result"
	| "emotion"
	| "insight";

// View mode for canvas/list toggle
export type ViewMode = "list" | "canvas";

// Mock mode scenario types (development only)
export type ConversationScenario =
	| "fresh-start"
	| "building-momentum"
	| "tension-discovery"
	| "completion-ready";

// Store State
interface PersonaStoreState {
	// === UI State ===
	viewMode: ViewMode;

	// === Mock Mode (Development Only) ===
	mockMode: boolean;
	mockScenario: ConversationScenario;

	// === Graph-Based Conversation State (from chat mutations) ===
	apiGraphNodes: PersonaNodeDto[];
	apiGraphEdges: PersonaEdgeDto[];
	coverage: CoverageMetrics;
	completionReady: boolean;
	totalNodeCount: number;
	starGapsMap: Record<string, StarStructureKey[]>; // nodeId -> missing STAR elements

	// === Persisted Chat Messages ===
	graphMessages: ConversationMessage[];

	// === Actions ===

	// UI actions
	setViewMode: (mode: ViewMode) => void;

	// Mock mode actions (development only)
	setMockMode: (enabled: boolean) => void;
	setMockScenario: (scenario: ConversationScenario) => void;

	// Graph update actions (called from ChatSidebar mutation callbacks)
	processGraphUpdate: (response: GraphMessageResponse) => void;
	setCoverage: (coverage: CoverageMetrics) => void;
	setCompletionReady: (ready: boolean) => void;
	addStarGaps: (nodeId: string, gaps: StarStructureKey[]) => void;
	clearApiGraph: () => void;
	getStarGapsForNode: (nodeId: string) => StarStructureKey[];

	// Chat message actions
	addGraphMessage: (message: ConversationMessage) => void;
	updateMessageStatus: (id: string, status: "sent" | "error") => void;
	clearGraphMessages: () => void;

	// Utility
	resetPersona: () => void;
	syncWithServer: (data: PersonaStateResponse) => void;
	syncGraph: (nodes: PersonaNodeDto[], edges: PersonaEdgeDto[]) => void;

	// Hydration state
	_hasHydrated: boolean;
	setHasHydrated: (state: boolean) => void;
}

// Initial state
const initialState = {
	// UI state
	viewMode: "canvas" as ViewMode,

	// Mock mode (development only)
	mockMode: false,
	mockScenario: "fresh-start" as ConversationScenario,

	// Graph-based conversation state
	apiGraphNodes: [] as PersonaNodeDto[],
	apiGraphEdges: [] as PersonaEdgeDto[],
	coverage: {
		goals: 0,
		evidence: 0,
		skills: 0,
		values: 0,
		tensions: 0,
		lowestCategory: undefined,
		overallProgress: 0,
	} as CoverageMetrics,
	completionReady: false,
	totalNodeCount: 0,
	starGapsMap: {} as Record<string, StarStructureKey[]>,

	// Persisted chat messages
	graphMessages: [] as ConversationMessage[],

	// Hydration state
	_hasHydrated: false,
};

export const usePersonaStore = create<PersonaStoreState>()(
	persist(
		(set, get) => ({
			// Initial State
			...initialState,

			// === UI Actions ===
			setViewMode: (mode) => set({ viewMode: mode }),

			// === Mock Mode Actions ===
			setMockMode: (enabled) => set({ mockMode: enabled }),
			setMockScenario: (scenario) => set({ mockScenario: scenario }),

			// === Graph Update Actions ===

			// Process graph update from API response (called from ChatSidebar mutation callbacks)
			processGraphUpdate: (response: GraphMessageResponse) => {
				set((state) => {
					// Add new nodes (avoid duplicates) - handle optional nodesCreated
					const nodesCreated = response.nodesCreated ?? [];
					const existingNodeIds = new Set(state.apiGraphNodes.map((n) => n.id));
					const newNodes = nodesCreated.filter(
						(n) => n.id && !existingNodeIds.has(n.id),
					);

					// Add new edges (avoid duplicates) - handle optional edgesCreated
					const edgesCreated = response.edgesCreated ?? [];
					const existingEdgeIds = new Set(state.apiGraphEdges.map((e) => e.id));
					const newEdges = edgesCreated.filter(
						(e) => e.id && !existingEdgeIds.has(e.id),
					);

					// Update STAR gaps for the last story if provided
					const starGapsMap = { ...state.starGapsMap };
					if (
						response.starGapsForLastStory &&
						response.starGapsForLastStory.length > 0
					) {
						// Find the last key_story node created
						const lastStoryNode = [...newNodes]
							.reverse()
							.find((n) => n.type === "key_story");
						if (lastStoryNode?.id) {
							// Cast string[] to StarStructureKey[] since API returns string[]
							starGapsMap[lastStoryNode.id] =
								response.starGapsForLastStory as StarStructureKey[];
						}
					}

					return {
						apiGraphNodes: [...state.apiGraphNodes, ...newNodes],
						apiGraphEdges: [...state.apiGraphEdges, ...newEdges],
						coverage: response.coverage ?? state.coverage,
						completionReady: response.completionReady ?? state.completionReady,
						totalNodeCount: response.totalNodeCount ?? state.totalNodeCount,
						starGapsMap,
					};
				});
			},

			// Set coverage metrics
			setCoverage: (coverage: CoverageMetrics) => set({ coverage }),

			// Set completion ready flag
			setCompletionReady: (ready: boolean) => set({ completionReady: ready }),

			// Add STAR gaps for a specific node
			addStarGaps: (nodeId: string, gaps: StarStructureKey[]) => {
				set((state) => ({
					starGapsMap: {
						...state.starGapsMap,
						[nodeId]: gaps,
					},
				}));
			},

			// Clear API graph data (used on reset)
			clearApiGraph: () =>
				set({
					apiGraphNodes: [],
					apiGraphEdges: [],
					coverage: {
						goals: 0,
						evidence: 0,
						skills: 0,
						values: 0,
						tensions: 0,
						lowestCategory: undefined,
						overallProgress: 0,
					},
					completionReady: false,
					totalNodeCount: 0,
					starGapsMap: {},
				}),

			// Get STAR gaps for a specific node
			getStarGapsForNode: (nodeId: string): StarStructureKey[] => {
				return get().starGapsMap[nodeId] || [];
			},

			// === Chat Message Actions ===

			// Add a message to the graph conversation
			addGraphMessage: (message: ConversationMessage) => {
				set((state) => ({
					graphMessages: [...state.graphMessages, message],
				}));
			},

			// Update the status of a message (e.g., from "sending" to "sent")
			updateMessageStatus: (id: string, status: "sent" | "error") => {
				set((state) => ({
					graphMessages: state.graphMessages.map((msg) =>
						msg.id === id ? { ...msg, status } : msg,
					),
				}));
			},

			// Clear all graph messages (used on reset)
			clearGraphMessages: () => set({ graphMessages: [] }),

			// === Utility ===

			// Reset all persona data (preserves hydration state)
			resetPersona: () =>
				set((state) => ({
					...initialState,
					// Preserve hydration state - component already rendered, just clearing data
					_hasHydrated: state._hasHydrated,
				})),

			// Sync state from server response (GET /v1/persona)
			// Note: Only sync if server has MORE messages than local, to prevent
			// overwriting messages that were just added by mutations but not yet
			// reflected in the server response.
			syncWithServer: (data: PersonaStateResponse) => {
				set((state) => {
					// Transform API messages to store format
					const serverMessages: ConversationMessage[] =
						data.conversationHistory?.map((msg) => {
							// Map API message type to store message type
							let mappedType: ConversationMessage["type"] = "text";
							if (msg.type === "track_complete") mappedType = "completion";
							// track_selection and text map to "text" for now, or could vary

							return {
								id: msg.id || `msg-${Date.now()}-${Math.random()}`,
								role: (msg.role as "user" | "assistant") || "assistant",
								content: msg.content || "",
								type: mappedType,
								timestamp: msg.timestamp || new Date().toISOString(),
							};
						}) || [];

					const localMessages = state.graphMessages;

					// Robust Sync Logic using Status:
					// 1. Server is the source of truth for all confirmed history
					// 2. We preserve local messages that are still "sending" (optimistic updates)

					const pendingMessages = localMessages.filter(
						(m) => m.status === "sending",
					);

					// If server has content, we generally trust it completely for the "sent" portion
					// We only append our pending messages to the end

					// Check if we effectively need to sync (avoid unnecessary re-renders)
					// We sync if:
					// 1. Server has more/different messages than our local "sent" messages
					// 2. We have pending messages that need to be re-appended

					const localSentMessages = localMessages.filter(
						(m) => m.status !== "sending",
					);

					// Simple check: IDs of last confirmed message
					const serverLastId =
						serverMessages.length > 0
							? serverMessages[serverMessages.length - 1].id
							: null;
					const localLastSentId =
						localSentMessages.length > 0
							? localSentMessages[localSentMessages.length - 1].id
							: null;

					const isServerDifferent =
						serverLastId !== localLastSentId ||
						serverMessages.length !== localSentMessages.length;

					if (isServerDifferent) {
						console.log(
							"ðŸ”„ [PersonaStore] Syncing conversation with server (Server state preferred)",
							{
								serverCount: serverMessages.length,
								localSentCount: localSentMessages.length,
								pendingCount: pendingMessages.length,
							},
						);

						return {
							graphMessages: [...serverMessages, ...pendingMessages],
						};
					}

					return { graphMessages: state.graphMessages };
				});
			},

			// Sync graph data (GET /v1/persona-graph)
			// Note: Only sync if server has MORE nodes than local, to prevent
			// overwriting nodes that were just added by mutations but not yet
			// reflected in the server response.
			syncGraph: (nodes: PersonaNodeDto[], edges: PersonaEdgeDto[]) => {
				set((state) => {
					const localNodes = state.apiGraphNodes;
					let shouldSync = false;

					// 1. Server has MORE nodes (new content)
					if (nodes.length > localNodes.length) {
						shouldSync = true;
					}
					// 2. Server is empty but local is not (Reset on another device)
					else if (nodes.length === 0 && localNodes.length > 0) {
						shouldSync = true;
					}
					// 3. Different Graph context
					else if (nodes.length > 0 && localNodes.length > 0) {
						// Check if the server's first node exists in local graph
						// If not, it means the server graph is completely different
						const serverFirstId = nodes[0].id;
						const localHasFirstServerNode = localNodes.some(
							(n) => n.id === serverFirstId,
						);

						if (!localHasFirstServerNode) {
							shouldSync = true;
						}
					}

					return {
						apiGraphNodes: shouldSync ? nodes : state.apiGraphNodes,
						apiGraphEdges: shouldSync ? edges : state.apiGraphEdges,
					};
				});
			},

			// Hydration state
			setHasHydrated: (state) => set({ _hasHydrated: state }),
		}),
		{
			name: "leaply-persona-store-v4", // Bump version to clear old data
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				// Only persist essential data
				viewMode: state.viewMode,
				apiGraphNodes: state.apiGraphNodes,
				apiGraphEdges: state.apiGraphEdges,
				coverage: state.coverage,
				completionReady: state.completionReady,
				totalNodeCount: state.totalNodeCount,
				starGapsMap: state.starGapsMap,
				graphMessages: state.graphMessages,
			}),
			onRehydrateStorage: () => (state, error) => {
				if (error) {
					console.error("Persona store hydration error:", error);
				}
				state?.setHasHydrated(true);
			},
		},
	),
);

// Register hydration listener using persist API
if (typeof window !== "undefined") {
	if (usePersonaStore.persist.hasHydrated()) {
		usePersonaStore.getState().setHasHydrated(true);
	}
	usePersonaStore.persist.onFinishHydration(() => {
		usePersonaStore.getState().setHasHydrated(true);
	});
}

// Selectors for common use cases
export const selectViewMode = (state: PersonaStoreState) => state.viewMode;
export const selectApiGraphNodes = (state: PersonaStoreState) =>
	state.apiGraphNodes;
export const selectApiGraphEdges = (state: PersonaStoreState) =>
	state.apiGraphEdges;
export const selectCoverage = (state: PersonaStoreState) => state.coverage;
export const selectCompletionReady = (state: PersonaStoreState) =>
	state.completionReady;
export const selectTotalNodeCount = (state: PersonaStoreState) =>
	state.totalNodeCount;
export const selectStarGapsMap = (state: PersonaStoreState) =>
	state.starGapsMap;
export const selectGraphMessages = (state: PersonaStoreState) =>
	state.graphMessages;

// Re-export generated types for convenience
export type {
	CoverageMetrics,
	GraphMessageResponse,
	PersonaEdgeDto,
	PersonaNodeDto,
} from "@/lib/generated/api/models";
