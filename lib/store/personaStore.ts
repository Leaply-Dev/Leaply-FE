/**
 * Persona Lab Store
 *
 * Simplified store for the graph-based persona conversation system.
 * Uses TanStack Query for server state, Zustand only for:
 * - UI state (viewMode)
 * - Persisted chat messages (graphMessages)
 * - Real-time graph data from mutations (apiGraphNodes/Edges)
 * - STAR gaps tracking
 * - Parts progress (guided flow)
 * - Archetype reveal state
 */
import { create } from "zustand";
import { createJSONStorage, persist } from "zustand/middleware";
import type { PartKey, PartsProgress } from "@/lib/config/partsConfig";
import type {
	ArchetypeDtoType,
	CoverageMetrics,
	GraphMessageResponse,
	PersonaEdgeDto,
	PersonaNodeDto,
	PersonaStateResponse,
} from "@/lib/generated/api/models";

// Frontend-specific types not generated by Orval
export interface ConversationMessage {
	id: string;
	role: "assistant" | "user";
	content: string;
	type: "text" | "question" | "completion";
	timestamp: string;
	/** Duration in milliseconds for how long the AI took to respond */
	thinkingDuration?: number;
	/** Status of the message for optimistic UI updates */
	status?: "sending" | "sent" | "error";
}

// STAR framework keys for gap tracking
export type StarStructureKey =
	| "situation"
	| "task"
	| "action"
	| "result"
	| "emotion"
	| "insight";

// View mode for canvas/list toggle
export type ViewMode = "list" | "canvas";

// Mock mode scenario types (development only)
export type ConversationScenario =
	| "fresh-start"
	| "building-momentum"
	| "tension-discovery"
	| "completion-ready";

// Guided conversation state (from backend)
export interface GuidedConversationState {
	phase: "questioning" | "completed";
	currentPart: PartKey | null;
	currentQuestionId: string | null;
	followUpCount: number;
}

// Store State
interface PersonaStoreState {
	// === UI State ===
	viewMode: ViewMode;

	// === Mock Mode (Development Only) ===
	mockMode: boolean;
	mockScenario: ConversationScenario;

	// === Graph-Based Conversation State (from chat mutations) ===
	apiGraphNodes: PersonaNodeDto[];
	apiGraphEdges: PersonaEdgeDto[];
	coverage: CoverageMetrics;
	completionReady: boolean;
	totalNodeCount: number;
	starGapsMap: Record<string, StarStructureKey[]>; // nodeId -> missing STAR elements

	// === Parts Progress (Guided Flow) ===
	partsProgress: PartsProgress;
	conversationState: GuidedConversationState | null;

	// === Archetype State ===
	archetypeType: ArchetypeDtoType | null;
	archetypeRevealed: boolean;
	showArchetypeModal: boolean;

	// === Persisted Chat Messages ===
	graphMessages: ConversationMessage[];

	// === Actions ===

	// UI actions
	setViewMode: (mode: ViewMode) => void;

	// Mock mode actions (development only)
	setMockMode: (enabled: boolean) => void;
	setMockScenario: (scenario: ConversationScenario) => void;

	// Graph update actions (called from ChatSidebar mutation callbacks)
	processGraphUpdate: (response: GraphMessageResponse) => void;
	setCoverage: (coverage: CoverageMetrics) => void;
	setCompletionReady: (ready: boolean) => void;
	addStarGaps: (nodeId: string, gaps: StarStructureKey[]) => void;
	clearApiGraph: () => void;
	getStarGapsForNode: (nodeId: string) => StarStructureKey[];

	// Parts progress actions (guided flow)
	setPartsProgress: (progress: PartsProgress) => void;
	setConversationState: (state: GuidedConversationState | null) => void;
	updatePartStatus: (part: PartKey, status: PartsProgress[PartKey]) => void;

	// Archetype actions
	setArchetype: (type: ArchetypeDtoType) => void;
	setShowArchetypeModal: (show: boolean) => void;

	// Chat message actions
	addGraphMessage: (message: ConversationMessage) => void;
	updateMessageStatus: (id: string, status: "sent" | "error") => void;
	clearGraphMessages: () => void;

	// Utility
	resetPersona: () => void;
	syncWithServer: (data: PersonaStateResponse) => void;
	syncGraph: (nodes: PersonaNodeDto[], edges: PersonaEdgeDto[]) => void;

	// Hydration state
	_hasHydrated: boolean;
	setHasHydrated: (state: boolean) => void;
}

// Default parts progress
const defaultPartsProgress: PartsProgress = {
	part1: "not_started",
	part2: "not_started",
	part3: "not_started",
	part4: "not_started",
};

// Initial state
const initialState = {
	// UI state
	viewMode: "canvas" as ViewMode,

	// Mock mode (development only)
	mockMode: false,
	mockScenario: "fresh-start" as ConversationScenario,

	// Graph-based conversation state
	apiGraphNodes: [] as PersonaNodeDto[],
	apiGraphEdges: [] as PersonaEdgeDto[],
	coverage: {
		goals: 0,
		evidence: 0,
		skills: 0,
		values: 0,
		tensions: 0,
		lowestCategory: undefined,
		overallProgress: 0,
	} as CoverageMetrics,
	completionReady: false,
	totalNodeCount: 0,
	starGapsMap: {} as Record<string, StarStructureKey[]>,

	// Parts progress (guided flow)
	partsProgress: defaultPartsProgress,
	conversationState: null as GuidedConversationState | null,

	// Archetype state
	archetypeType: null as ArchetypeDtoType | null,
	archetypeRevealed: false,
	showArchetypeModal: false,

	// Persisted chat messages
	graphMessages: [] as ConversationMessage[],

	// Hydration state
	_hasHydrated: false,
};

export const usePersonaStore = create<PersonaStoreState>()(
	persist(
		(set, get) => ({
			// Initial State
			...initialState,

			// === UI Actions ===
			setViewMode: (mode) => set({ viewMode: mode }),

			// === Mock Mode Actions ===
			setMockMode: (enabled) => set({ mockMode: enabled }),
			setMockScenario: (scenario) => set({ mockScenario: scenario }),

			// === Graph Update Actions ===

			// Process graph update from API response (called from ChatSidebar mutation callbacks)
			processGraphUpdate: (response: GraphMessageResponse) => {
				set((state) => {
					// Add new nodes (avoid duplicates) - handle optional nodesCreated
					const nodesCreated = response.nodesCreated ?? [];
					const existingNodeIds = new Set(state.apiGraphNodes.map((n) => n.id));
					const newNodes = nodesCreated.filter(
						(n) => n.id && !existingNodeIds.has(n.id),
					);

					// Add new edges (avoid duplicates) - handle optional edgesCreated
					const edgesCreated = response.edgesCreated ?? [];
					const existingEdgeIds = new Set(state.apiGraphEdges.map((e) => e.id));
					const newEdges = edgesCreated.filter(
						(e) => e.id && !existingEdgeIds.has(e.id),
					);

					// Update STAR gaps for the last story if provided
					const starGapsMap = { ...state.starGapsMap };
					if (
						response.starGapsForLastStory &&
						response.starGapsForLastStory.length > 0
					) {
						// Find the last key_story node created
						const lastStoryNode = [...newNodes]
							.reverse()
							.find((n) => n.type === "key_story");
						if (lastStoryNode?.id) {
							// Cast string[] to StarStructureKey[] since API returns string[]
							starGapsMap[lastStoryNode.id] =
								response.starGapsForLastStory as StarStructureKey[];
						}
					}

					return {
						apiGraphNodes: [...state.apiGraphNodes, ...newNodes],
						apiGraphEdges: [...state.apiGraphEdges, ...newEdges],
						coverage: response.coverage ?? state.coverage,
						completionReady: response.completionReady ?? state.completionReady,
						totalNodeCount: response.totalNodeCount ?? state.totalNodeCount,
						starGapsMap,
					};
				});
			},

			// Set coverage metrics
			setCoverage: (coverage: CoverageMetrics) => set({ coverage }),

			// Set completion ready flag
			setCompletionReady: (ready: boolean) => set({ completionReady: ready }),

			// Add STAR gaps for a specific node
			addStarGaps: (nodeId: string, gaps: StarStructureKey[]) => {
				set((state) => ({
					starGapsMap: {
						...state.starGapsMap,
						[nodeId]: gaps,
					},
				}));
			},

			// Clear API graph data (used on reset)
			clearApiGraph: () =>
				set({
					apiGraphNodes: [],
					apiGraphEdges: [],
					coverage: {
						goals: 0,
						evidence: 0,
						skills: 0,
						values: 0,
						tensions: 0,
						lowestCategory: undefined,
						overallProgress: 0,
					},
					completionReady: false,
					totalNodeCount: 0,
					starGapsMap: {},
					partsProgress: defaultPartsProgress,
					conversationState: null,
					archetypeType: null,
					archetypeRevealed: false,
					showArchetypeModal: false,
				}),

			// Get STAR gaps for a specific node
			getStarGapsForNode: (nodeId: string): StarStructureKey[] => {
				return get().starGapsMap[nodeId] || [];
			},

			// === Parts Progress Actions (Guided Flow) ===

			setPartsProgress: (progress: PartsProgress) =>
				set({ partsProgress: progress }),

			setConversationState: (state: GuidedConversationState | null) =>
				set({ conversationState: state }),

			updatePartStatus: (part: PartKey, status: PartsProgress[PartKey]) => {
				set((state) => ({
					partsProgress: {
						...state.partsProgress,
						[part]: status,
					},
				}));
			},

			// === Archetype Actions ===

			setArchetype: (type: ArchetypeDtoType) =>
				set({
					archetypeType: type,
					archetypeRevealed: true,
					showArchetypeModal: true, // Show celebration modal
				}),

			setShowArchetypeModal: (show: boolean) =>
				set({ showArchetypeModal: show }),

			// === Chat Message Actions ===

			// Add a message to the graph conversation
			addGraphMessage: (message: ConversationMessage) => {
				set((state) => ({
					graphMessages: [...state.graphMessages, message],
				}));
			},

			// Update the status of a message (e.g., from "sending" to "sent")
			updateMessageStatus: (id: string, status: "sent" | "error") => {
				set((state) => ({
					graphMessages: state.graphMessages.map((msg) =>
						msg.id === id ? { ...msg, status } : msg,
					),
				}));
			},

			// Clear all graph messages (used on reset)
			clearGraphMessages: () => set({ graphMessages: [] }),

			// === Utility ===

			// Reset all persona data (preserves hydration state)
			resetPersona: () =>
				set((state) => ({
					...initialState,
					// Preserve hydration state - component already rendered, just clearing data
					_hasHydrated: state._hasHydrated,
				})),

			// Sync state from server response (GET /v1/persona)
			// Note: Only sync if server has MORE messages than local, to prevent
			// overwriting messages that were just added by mutations but not yet
			// reflected in the server response.
			syncWithServer: (data: PersonaStateResponse) => {
				set((state) => {
					// Transform API messages to store format
					const serverMessages: ConversationMessage[] =
						data.conversationHistory?.map((msg) => {
							// Map API message type to store message type
							// API type is "text" only now, but we keep flexibility for future types
							let mappedType: ConversationMessage["type"] = "text";
							const msgTypeStr = msg.type as string | undefined;
							if (
								msgTypeStr === "completion" ||
								msgTypeStr === "track_complete"
							)
								mappedType = "completion";
							if (msgTypeStr === "question") mappedType = "question";

							return {
								id: msg.id || `msg-${Date.now()}-${Math.random()}`,
								role: (msg.role as "user" | "assistant") || "assistant",
								content: msg.content || "",
								type: mappedType,
								timestamp: msg.timestamp || new Date().toISOString(),
							};
						}) || [];

					const localMessages = state.graphMessages;

					// Robust Sync Logic using Status:
					// 1. Server is the source of truth for all confirmed history
					// 2. We preserve local messages that are still "sending" (optimistic updates)

					const pendingMessages = localMessages.filter(
						(m) => m.status === "sending",
					);

					// If server has content, we generally trust it completely for the "sent" portion
					// We only append our pending messages to the end

					// Check if we effectively need to sync (avoid unnecessary re-renders)
					// We sync if:
					// 1. Server has more/different messages than our local "sent" messages
					// 2. We have pending messages that need to be re-appended

					const localSentMessages = localMessages.filter(
						(m) => m.status !== "sending",
					);

					// Simple check: IDs of last confirmed message
					const serverLastId =
						serverMessages.length > 0
							? serverMessages[serverMessages.length - 1].id
							: null;
					const localLastSentId =
						localSentMessages.length > 0
							? localSentMessages[localSentMessages.length - 1].id
							: null;

					const isServerDifferent =
						serverLastId !== localLastSentId ||
						serverMessages.length !== localSentMessages.length;

					// Sync archetype from server if available
					const archetypeUpdates: Partial<PersonaStoreState> = {};
					if (data.archetype?.type && !state.archetypeRevealed) {
						archetypeUpdates.archetypeType = data.archetype
							.type as ArchetypeDtoType;
						archetypeUpdates.archetypeRevealed = true;
					}

					if (isServerDifferent) {
						console.log(
							"ðŸ”„ [PersonaStore] Syncing conversation with server (Server state preferred)",
							{
								serverCount: serverMessages.length,
								localSentCount: localSentMessages.length,
								pendingCount: pendingMessages.length,
							},
						);

						return {
							graphMessages: [...serverMessages, ...pendingMessages],
							...archetypeUpdates,
						};
					}

					return {
						graphMessages: state.graphMessages,
						...archetypeUpdates,
					};
				});
			},

			// Sync graph data (GET /v1/persona-graph)
			// ALWAYS use server data to ensure consistency
			// This prevents issues with corrupted localStorage data
			syncGraph: (nodes: PersonaNodeDto[], edges: PersonaEdgeDto[]) => {
				set((state) => {
					const localNodes = state.apiGraphNodes;

					// Debug: Log sync decision
					console.log("ðŸ”„ [PersonaStore] syncGraph called:", {
						serverNodeCount: nodes.length,
						localNodeCount: localNodes.length,
						serverIds: nodes.map((n) => n.id?.substring(0, 8)),
						localIds: localNodes.map((n) => n.id?.substring(0, 8)),
					});

					// ALWAYS sync with server data when server has nodes
					// This ensures we never use stale/corrupted localStorage data
					if (nodes.length > 0) {
						console.log(
							"âœ… [PersonaStore] Using server data (nodes:",
							nodes.length,
							")",
						);
						return {
							apiGraphNodes: nodes,
							apiGraphEdges: edges,
						};
					}

					// Server is empty - check if we should clear local data
					if (nodes.length === 0 && localNodes.length > 0) {
						console.log("âš ï¸ [PersonaStore] Server empty, clearing local data");
						return {
							apiGraphNodes: [],
							apiGraphEdges: [],
						};
					}

					// Both empty - no change needed
					return state;
				});
			},

			// Hydration state
			setHasHydrated: (state) => set({ _hasHydrated: state }),
		}),
		{
			name: "leaply-persona-store-v5", // Bump version for new parts-based flow
			storage: createJSONStorage(() => localStorage),
			partialize: (state) => ({
				// Only persist essential data
				viewMode: state.viewMode,
				apiGraphNodes: state.apiGraphNodes,
				apiGraphEdges: state.apiGraphEdges,
				coverage: state.coverage,
				completionReady: state.completionReady,
				totalNodeCount: state.totalNodeCount,
				starGapsMap: state.starGapsMap,
				graphMessages: state.graphMessages,
				// New fields for guided flow
				partsProgress: state.partsProgress,
				archetypeType: state.archetypeType,
				archetypeRevealed: state.archetypeRevealed,
			}),
			onRehydrateStorage: () => (state, error) => {
				if (error) {
					console.error("Persona store hydration error:", error);
				}
				state?.setHasHydrated(true);
			},
		},
	),
);

// Register hydration listener using persist API
if (typeof window !== "undefined") {
	if (usePersonaStore.persist.hasHydrated()) {
		usePersonaStore.getState().setHasHydrated(true);
	}
	usePersonaStore.persist.onFinishHydration(() => {
		usePersonaStore.getState().setHasHydrated(true);
	});
}

// Selectors for common use cases
export const selectViewMode = (state: PersonaStoreState) => state.viewMode;
export const selectApiGraphNodes = (state: PersonaStoreState) =>
	state.apiGraphNodes;
export const selectApiGraphEdges = (state: PersonaStoreState) =>
	state.apiGraphEdges;
export const selectCoverage = (state: PersonaStoreState) => state.coverage;
export const selectCompletionReady = (state: PersonaStoreState) =>
	state.completionReady;
export const selectTotalNodeCount = (state: PersonaStoreState) =>
	state.totalNodeCount;
export const selectStarGapsMap = (state: PersonaStoreState) =>
	state.starGapsMap;
export const selectGraphMessages = (state: PersonaStoreState) =>
	state.graphMessages;

// New selectors for guided flow
export const selectPartsProgress = (state: PersonaStoreState) =>
	state.partsProgress;
export const selectConversationState = (state: PersonaStoreState) =>
	state.conversationState;
export const selectArchetypeType = (state: PersonaStoreState) =>
	state.archetypeType;
export const selectArchetypeRevealed = (state: PersonaStoreState) =>
	state.archetypeRevealed;
export const selectShowArchetypeModal = (state: PersonaStoreState) =>
	state.showArchetypeModal;

// Re-export Parts types
export type { PartKey, PartsProgress } from "@/lib/config/partsConfig";
// Re-export generated types for convenience
export type {
	CoverageMetrics,
	GraphMessageResponse,
	PersonaEdgeDto,
	PersonaNodeDto,
} from "@/lib/generated/api/models";
